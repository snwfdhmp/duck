#!/bin/bash

# Duck - Project management
# Developed and maintained by Martin Joly (https://github.com/snwfdhmp/)
# Project repo : https://github.com/snwfdhmp/duck
# Under MIT License
# Please include a link to my repo when you share

DUCK_VERSION="0.7"

storage="/etc" #default mac app storage
if [ ! -d "$storage" ]; then
    storage="/var/lib"
    if [ ! -d "$storage" ]; then
        echo "No configuration dir found"
        exit 1
    fi
fi

storage="$storage/duck"

if [ ! -d $storage ]; then
    echo "No configuration folder found. Creating one at $storage (permissions : 750)"
    sudo mkdir $storage
    sudo chmod 777 $storage
fi

if [ ! $(ls "$storage/duck.conf" > /dev/null 2> /dev/null;echo $?) -eq 0 ]; then
    echo "No duck configuration file found in $storage (duck.conf). Creating one (permissions : 750)"
    echo

    echo "#!/bin/bash" > $storage/duck.conf
    echo "(project_storage)=$(pwd)" >> $storage/duck.conf
    echo 'build_dir=build' >> $storage/duck.conf
    echo 'backups_dir=backups' >> $storage/duck.conf
    echo 'config_dir=config' >> $storage/duck.conf
    echo 'doc_dir=doc' >> $storage/duck.conf
    echo 'junk_dir=junk' >> $storage/duck.conf
    echo 'logs_dir=logs' >> $storage/duck.conf
    echo 'src_dir=src' >> $storage/duck.conf
    echo 'classes_dir=classes' >> $storage/duck.conf
    echo 'tests_dir=tests' >> $storage/duck.conf
    echo 'source_config_dir=config' >> $storage/duck.conf
    echo 'class_extension=class' >> $storage/duck.conf
    echo 'code_extension=cpp' >> $storage/duck.conf
    echo 'header_extension=hpp' >> $storage/duck.conf
    echo 'dependencies_extension=dep' >> $storage/duck.conf
    echo 'test_extension=test' >> $storage/duck.conf
    echo 'base_version=0.1' >> $storage/duck.conf
    echo 'base_suffix=-1' >> $storage/duck.conf
    echo 'default_env=dev' >> $storage/duck.conf
    echo 'default_qc_message="Quick commit"' >> $storage/duck.conf
    echo "project_name=$project_name" >> $storage/duck.conf
    echo "project_root=$project_root" >> $storage/duck.conf

    chmod 750 $storage/duck.conf
fi

function project_storage() {
    echo "$project_root/.duck"
}

function configInit() {

    if [ ! -d $(project_storage) ]; then
        echo "Error : cannot find project_storage (is not at $(project_storage))"
        echo "type 'duck repair' for more informations"
        exit 1
    fi

    default_conf=$storage/duck.conf

    if [ ! -z "$new_config_path" ];then
        if [ $(ls $new_config_path |echo $?) -eq 0 ]; then
            echo "$new_config_path : no such file."
            exit 1
        fi
        default_conf=new_config_path
    fi

    cp $default_conf $(project_storage)/duck.conf
    if [ -z "$project_name" ]; then 
        echo "Enter a name for this project : "
        read project_name
    fi
    if [ -z "$project_root" ]; then
        echo "Enter the path for this project : ."
        read project_root
    fi
    chmod 750 $(project_storage)/duck.conf
}

function init() {
    if [ -z "$project_root" ]; then
        project_root="."
    fi

    if [ ! -d "$(project_storage)" ]; then
        if [ $action = "init" ]; then
            if [ ! -d $project_root ]; then
                echo "Duck: $project_root doesn't exist yet, we'll create it for you."
                mkdir $project_root
                chmod 750 $project_root
            fi
            echo "Duck: New project : creation of .duck storage"
            mkdir .duck
            chmod 750 .duck
        else
            project_root="../$project_root"
            if [ ! -d "$project_root/.duck" ]; then
                project_root="../$project_root"
                if [ ! -d "$project_root/.duck" ]; then
                    echo "Cannot find .duck storage. Try repairing with 'duck repair'"
                    exit 1
                fi
            fi
        fi
    fi

    old_pwd=$(pwd)
    cd $project_root
    project_root=$(pwd)
    cd "$old_pwd"


    if [ ! $(ls "$(project_storage)/duck.conf" > /dev/null 2> /dev/null;echo $?) -eq 0 ]; then
        if [ ! "$action" = "init" ]; then
           echo "No project configuration file found in $(project_storage) (duck.conf). Creating one (permissions : 750)"
       fi
       configInit
   fi

   . $storage/duck.conf
   . $(project_storage)/duck.conf

   if [ -z "$project_name" ]; then
    if [ ! "$action" = "init" ]; then
        echo "No name has been set for this projet yet."
    fi
    default_name=$(basename $(pwd))
    echo "Enter a name [ENTER for '$default_name'] : "
    read project_name
    if [ -z "$project_name" || $project_name = "" ]; then
        project_name=default_name
    fi
    echo "project_name=$project_name" >> $storage/duck.conf
fi

if [ -z "$project_root" ]; then
    echo "No project path"
    exit 1
fi

}

function deploy() {
    init

    if [ -z $project_root ]; then
        project_root="."
    fi

    mkdir $project_root/$build_dir $project_root/$backups_dir $project_root/$config_dir $project_root/$doc_dir $project_root/$junk_dir $project_root/$logs_dir $project_root/$src_dir $project_root/$src_dir/$classes_dir $project_root/$src_dir/$source_config_dir $project_root/$src_dir/$tests_dir
    chmod 750 $project_root/*
    
    touch $project_root/$src_dir/$source_config_dir/UnitTests.$header_extension
    touch $project_root/$src_dir/$source_config_dir/Constants.$header_extension

    name="Example"
    classCreate > /dev/null

    echo "$version_base" > "$(project_storage)/version_base"
    echo "$version_suffix" > "$(project_storage)/version_suffix"
    touch "$project_root/$src_dir/main.$code_extension"

    if [ ! $(ls "$project_root/README.md" > /dev/null 2> /dev/null;echo $?) = "0" ]; then
        echo "#$project_name" > $project_root/README.md
        echo >> $project_root/README.md
        echo "This project uses duck architecture and is managed with [duck](https://github.com/snwfdhmp/duck)." >> $project_root/README.md
    fi

    echo ".duck" > $project_root/.gitignore
    echo ".DS_Store" > $project_root/.gitignore
    
    if [ ! "$(git init > /dev/null;echo $?)" = "0" ]; then
        echo "Error creating GitHub repository"
    else
        echo "git: Created repository"
    fi

    echo "duck: Succesfully deployed architecture for project $project_name"
}



function usage() {
    echo "usage: duck <options> "
    echo ""
    echo "Available options :"
    echo ""
    echo "name             usage                      description"
    echo "---------------  -------------------------  ---------------------------------"
    echo "init             duck init <name> [opt]     initialize a new duck project"
    echo "deploy           duck deploy [opt]          deploy duck architecture"
    echo "config           duck config <action> [opt] project configuration tools"
    echo "class            duck class <action> [opt]  tools for classes"
    echo "compile          duck compile [env]         run project compiler"
    echo "run              duck run [target-version]  run project (no arg->last version)"
    echo "project-version  duck pv [show|set|inc]     configuration for project version"
    echo "tar              duck tar                   backup 'src/' dir into a tarball"
    echo "quick-commit     duck qc [custom-msg]       alias git add *, commit, push"
    echo "doc              duck doc [command]         shows command's help message"
    echo "help             duck help                  shows this message"
}

function classUsage() {
    echo "usage: duck class <action> [option] "
    echo ""
    echo "Available types :"
    echo ""
    echo "name         description"
    echo "------       ------------------------------------"
    echo "create       creates a c++ class (with unit test)"
    echo "rm           removes a c++ class (move to junk/)"
    echo "list         list project's c++ classes"
}

function classCreateUsage() {
    echo "usage: duck class create <name> "
}
function classDelUsage() {
    echo "usage: duck class rm <name> "
}

function project_version_usage() {
    echo "usage: duck pv <options> "
    echo ""
    echo "Available options :"
    echo ""
    echo "name   usage                        description"
    echo "----   --------------------------   ---------------------------------------"
    echo "show   duck pv                      show actual project version"
    echo "set    duck pv set <version>        set project major version"
    echo "inc    (beta)duck pv inc [amount]   increments actual project major version"
}

function quick_commit() {
    init
    if [ -z "$msg" ]; then
        msg=$default_qc_message
        echo "Using default quick-commit message '$default_qc_message'"
    else
        echo "Using chosen commit message : '$msg'"
    fi
    git add *
    if [ ! $? -eq 0 ]; then
        echo "error during 'git add'."
        exit 1
    fi
    git commit -m "$msg"
    if [ ! $? -eq 0 ]; then
        echo "error during 'git commit'."
        exit 1
    fi
    git push > /dev/null 2> /dev/null &
    echo "Committed successfully, pushing in background"
    exit 0
}

function classList() {
    init
    for i in $src_dir/$classes_dir/*
    do
        echo "$(basename $i)"
    done
    exit 0
}

function classDel() {
    init
    if [ -z $name ]; then
        classDelUsage
        exit 1
    fi
    if [ ! -d "$src_dir/$classes_dir/$name" ];then
        echo "error : no such class '$name' (looking in $src_dir/$classes_dir/)"
        classDelUsage
        exit 1
    fi
    echo -n "You will delete '$src_dir/$classes_dir/$name/*'. Confirm ? [y/n] "
    read confirm
    case $confirm in
        y|Y) ;;
*) exit 1;;
esac
mv $src_dir/$classes_dir/$name junk/
echo "Class $name moved to junk"
exit 0
}

function classCreate() {
    init
    if [ -z "$name" ];then
        classCreateUsage
        exit 1
    fi

    mkdir $project_root/$src_dir/$classes_dir/$name
    touch $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    touch $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    touch $project_root/$src_dir/$classes_dir/$name/$name.$test_extension.$code_extension
    for i in $project_root/$src_dir/$classes_dir/$name/*; do
        echo "// Project $project_name [duck managed]" >> $i
        echo "// Class $name ($src_dir/$classes_dir/$name/$(basename $i))" >> $i
    done
    name_upper=$(echo "$name" | awk '{print toupper($0)}')
    class_upper=$(echo "$class_extension" | awk '{print toupper($0)}')
    code_upper=$(echo "$code_extension" | awk '{print toupper($0)}')
    header_upper=$(echo "$header_extension" | awk '{print toupper($0)}')
    test_upper=$(echo "$test_extension" | awk '{print toupper($0)}')
    echo "#ifndef ${name_upper}_${class_upper}_${code_upper}" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "#define ${name_upper}_${class_upper}_${code_upper}" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "//$name class methods implementation" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "#include \"$name.$class_extension.$header_extension\" " >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "//class constructor" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "$name::$name() {" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "    // object initialization" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "}" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    echo "#endif" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension
    
    echo "#ifndef ${name_upper}_${class_upper}_${header_upper}" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "#define ${name_upper}_${class_upper}_${header_upper}" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "//$name class definition" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "class $name" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "{" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "    public:" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "    $name(); //class constructor" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "    ~$name();" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "};" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension
    echo "#endif" >> $project_root/$src_dir/$classes_dir/$name/$name.$class_extension.$header_extension

    echo "#ifndef ${name_upper}_${class_upper}_${code_upper}">> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "#define ${name_upper}_${test_upper}_${code_upper}" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo " " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "//$name class unit test" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "  " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "#include <iostream>" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "#include \"$name.$class_extension.$header_extension\"" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "#include \"../../$source_config_dir/UnitTests.$header_extension\"" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "  " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "int main(int argc, char const *argv[])" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "{" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    unsigned int err = 0;" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    $name a;" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "  " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    /*" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    unit tests here" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    use macro SHOULD_BE_TRUE(expression) and SHOULD_BE_FALSE(expression)" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    to increment err when errors" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    */" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    if(err) {" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "        cout << 'Test failed with ' << err << ' errors.' << endl;" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "        return -1;" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    }" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "  " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    cout << 'Test executed successfully' << endl;" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "    return 0;" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "}" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "  " >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension
    echo "#endif" >> $project_root/$src_dir/$classes_dir/$name/$name.test.$code_extension

    echo >> $project_root/$src_dir/$classes_dir/$name/$name.test.dep\
    "$src_dir/$classes_dir/$name/$name.$class_extension.$code_extension"


    echo "Successfully created class $name"
}

function compile() {
    init

    if [ -z "$version_env" ]; then
        export COMPILE_ENV=$default_env
    else
        export COMPILE_ENV=$version_env
    fi

    linkAddOn=""

    if [ ! -z "$option" ]; then
        case $option in
            sdl) linkAddOn="-lSDL2"
;;
*) echo "Incorrect option"
;;
esac
fi


rm ./.DS_Store 2> /dev/null
rm */.DS_Store 2> /dev/null
rm */*/.DS_Store 2> /dev/null
rm */*/*/.DS_Store 2> /dev/null

version=$(cat $(project_storage)/version_base)
suffix=$(cat $(project_storage)/version_suffix)
suffix=$(($suffix+1))
log_compile_path="$logs_dir/compile.logs"

echo "Compilation de '$build_dir/$COMPILE_ENV-$version.$suffix.exe'..."
echo "[$(date)] ++ Compilation de '$build_dir/$COMPILE_ENV-$version.$suffix.exe' ..." >> $log_compile_path

g++ src/main.cpp src/$classes_dir/*/*.$class_extension.cpp -o $build_dir/$COMPILE_ENV-$version.$suffix.exe -Wall $linkAddOn

if [ $? -eq 0 ]; then
    chmod 710 $build_dir/$COMPILE_ENV-$version.$suffix.exe
    echo $suffix > "$(project_storage)/version_suffix"
    echo "$COMPILE_ENV-$version.$suffix.exe" > $(project_storage)/last_version
    echo "Compilation réussie"
fi

git add $log_compile_path $build_dir/$COMPILE_ENV-$version.$suffix.exe > /dev/null 2> /dev/null
git commit -m "Compilation de '$build_dir/$COMPILE_ENV-$version.$suffix.exe' ..." > /dev/null 2> /dev/null
git push > /dev/null 2> /dev/null &
echo "Commit & push to git in background"
exit 0
}

function run() {
    init 
    if [ -z $target ]; then
        echo "No target specified, taking last version by default."
        cat $(project_storage)/last_version > /dev/null 2> /dev/null
        if [ ! $? -eq 0 ]; then
            echo "Error : No last version found. (looking in $(project_storage)/last_version)"
            exit 1
        else
            target="$build_dir/$(cat $(project_storage)/last_version)"
            ls $target > /dev/null 2> /dev/null
            if [ ! $? -eq 0 ]; then
                echo "Error : last version ($target as set in $(project_storage)/last_version) doesn't seem to exist."
                exit 1
            fi
        fi
    else
        ls $build_dir/*-$target.exe >/dev/null 2> /dev/null
        if [ ! $? -eq 0 ];then
            echo "$target : targetted version not found. (ls $build_dir/*-$target.exe returned errors)"
            exit 1
        else
            target=$(ls $build_dir/*-$target.exe)
        fi
    fi
    echo "Running '$target' ..."
    echo ""
    $target
    exit 0
}

function project_version_set() {
    init
    actual_version=$(cat $(project_storage)/version_base)
    # TODO solve this (: integer expression expected (for if [ -lt ] ))
    #if [ $set_version -lt $actual_version ];then
    #    echo "Warning ! Changing version from $actual_version to earlier $set_version."
    #    echo "This may cause troubles in versioning."
    #    echo "Do you wish to continue ? [y/N]"
    #    prompt yesorno
    #    case $yesorno in
    #        yY) echo "Continuing"
    #            ;;
    #        *) exit 1
    #            ;;
    #    esac
    #fi

    echo $set_version > $(project_storage)/version_base
    echo "-1" > $(project_storage)/version_suffix
    echo "Version succesfully changed."
    echo "Next compile version : $set_version.0"
    exit 0
}

function project_version_inc() {
    init
    echo "Warning ! This function may not work properly. Please use 'duck pv set' instead."
    echo "Error. We decided to disable this function for now"
    exit 1
    if [ -z $amount ]; then
        echo "No amount specified, taking 0.1 by default"
        amount=0.1
    fi
    actual_version="$(cat $(project_storage)/version_base)"
    
    echo -n "Project version : $actual_version -> "
    actual_version="$(echo "$actual_version+$amount"|bc)"
    if [ $(echo $actual_version |grep ".*") = $actual_version ]; then
        actual_version="0$actual_version"
    fi
    echo "$actual_version"
    echo "$actual_version" > $(project_storage)/version_base
    exit 0
}

function project_version_show() {
    init
    echo "$(cat $(project_storage)/version_base).$(cat $(project_storage)/version_suffix)"
    exit 0
}

function source_archive() {
    init

    if [ ! -d $project_root/$backups_dir ]; then
        echo "No backup dir found, creating one ($backups_dir/)"
        mkdir $project_root/$backups_dir > /dev/null 2> /dev/null
    fi

    path="$backups_dir/$(cat $(project_storage)/version_base).$(cat $(project_storage)/version_suffix).$(date "+%d-%m-%y.%Hh%M").tar"
    echo "Archiving source code to $path"
    tar -cf $project_root/$path $project_root/$src_dir
    exit 0
}




#
#show)       action="configShow"
#edit)       action="configEdit"
#init)       action="configInit"
#set)        action="configSet"
#            new_config_path=$1
#

function configShow() {
    cat $(project_storage)/duck.conf
    exit 0
}

function configEdit() {
    nano $(project_storage)/duck.conf
    exit 0
}

function configUsage() {
    echo "usage: duck config <action> [option]"
    echo ""
    echo "Available actions :"
    echo ""
    echo "name         description"
    echo "------       ------------------------------------"
    echo "show         show current project configuration"
    echo "init         reset configuration file to default"
    echo "set <path>   set new configuration file"
    echo "edit         open configuration file with nano"
}

function open_source_in_editor() {
    subl $(which duck)
    exit 0
}

if [ -z "$1" ];then
    usage
    exit 1
fi

while [ "$1" != "" ]; do
    case $1 in
        deploy)                 action="deploy"
                                shift
                                project_root="$1"
;;
init)                   action="init"
shift
project_name=$1
;;

config)                 shift
case $1 in
    get | view | show)          action="configShow"
;;
edit | nano)        action="configEdit"
;;
init | set) action="configInit"
shift
new_config_path=$1
;;
*)          configUsage
exit 1
;;
esac
;;
qc | quick-commit)      action="quick_commit"
shift
msg=$1
;;
class )                     shift
case $1 in
    create)     shift
name=$1
action="classCreate"
;;
list| l)    action="classList"
;;
rm | del)   action="classDel"
shift
name=$1
;;
*)          classUsage  
exit 1
;;
esac
;;
compile )                   action="compile"
shift
version_env=$1
shift
option=$1
;;
-c )                        action="compile"
shift
version_env=""
option=$1
;;
run | -r)                   action="run"
shift
target=$1
;;
project-version | pv)       shift
if [ ! $(cat $(project_storage)/version_base 2>/dev/null > /dev/null |echo $?) -eq 0 ]; then
    echo "No project version found."
    echo "Do you want to initialize it to $version_base.$version_suffix ? [yn]"
    read yesorno
    case $yesorno in
        yY) echo $version_base > $(project_storage)/version_base
echo $version_suffix > $(project_storage)/version_suffix
;;
*)  exit 1
;;
esac
fi
case $1 in
    set)                        action="project_version_set"
shift
set_version=$1
;;
inc)                        action="project_version_inc"
shift
amount=$1
;;
show|"")                    action="project_version_show"
;;
*)                          project_version_usage
exit 1
;;
esac
;;
tar | -t)                   action="source_archive"
;;
doc | help | -h | --help )  echo "Using duck $DUCK_VERSION"
shift
if [ -z "$1" ]; then
    usage
    exit 0
fi
case $1 in
    class)              classUsage
exit 0
;;
pv|project-version) project_version_usage
exit 0
;;
*)                  echo "No help section for $1"
usage
exit 1
;;
esac
usage
exit
;;
edit-src )                      action="open_source_in_editor"
;;
* )                     usage
exit 1
;;
esac
shift
done


$action